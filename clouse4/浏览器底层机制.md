## JS 堆栈内存的运行机制

**JS 代码可以运行的环境**

- 浏览器[内核：webkit(blink)/gecko/presto/trident/chromium...]
- IOS/安卓原型 App 中，基于 webview 运行的页面和 js[内核：webkit]
  特点：支持 window、没有 global、支持 ES6Module 模块规范，不支持 CommonJS 模块规范
- Node [内核：webkit]
  特点：支持 global、不支持 window、支持 CommonJS、不支持 ES6Module
- webpack [基于 node 环境编译打包 js，最后把编译后的结果运行在浏览器中]
  特点：浏览器和 node 环境支持的都支持

  不论什么环境下执行代码，总要开辟出相关的内存(执行内存/内存条)，用来存储值[Heap 堆内存] 以及运行代码 [Stack 栈内存 -> E(Execution) C(Context) Stack 执行环境栈]

**栈内存 ECStack**
栈内存 ECStack(Execution Context Stack)

> JS 之所以能够在浏览器中运行，是因为浏览器给 JS 提供了执行的环境栈内存
> 浏览器会在计算机内存中分配一块内存，专门用来供代码执行 => 栈内存 `ECStack(Execution Context Stack)` 执行环境栈，每打开一个网页都会生成一个全新的 ECS

**ECS 的作用**

- 提供一个供 JS 代码自上而下执行的环境（代码都在栈中执行）
- 由于基本数据类型值比较简单，他们都是直接在栈内存中开辟一个位置，把值直接存储进去的，当栈内存被销毁，存储的那些基本值也都跟着销毁

**堆内存(Heap)**
堆内存：引用值对应的空间

存储引用类型值（对象：键值对， 函数：代码字符串），当内存释放销毁，那么这个引用值彻底没了
堆内存释放
当堆内存没有被任何得变量或者其他东西所占用，浏览器会在空闲的时候，自主进行内存回收，把所有不被占用得内存销毁掉

谷歌浏览器（webkit），每隔一定时间查找对象有没有被占用
引用计数器:当对象引用为 0 时释放它

**全局对象 GO**
全局对象 `GO(Global Object)`浏览器端会让 WINDOW 指向 GO

浏览器把内置得一些属性方法收到一个单独得内存中堆内存（Heap）任何开辟得内存都有一个 16 进制得内存地址，方便后期找到这个内存

**执行上下文 EC**
`EC(Execution Context)`执行上下文：代码自己执行所在的环境

全局的执行上下文 `EC(G)`
函数中的代码都会在一个单独的私有的执行上下文中处理
块级的执行上下文
形成的全局执行上下文，进入到栈内存中执行“进栈”
执行完代码，可能会把形成的上下文出栈释放“出栈”

**变量对象 VO**
`VO(Varibate Object)`变量对象：在当前上下文中，用来存放创建的变量和值的地方（每一个执行上下文中都有一个自己的变量对象，函数私有上下文中叫做 `AO(Activation Object)`活动对象，但也是变量对象）

`VO(G)`全局变量对象：全局上下文中用来存储全局变量的空间，它不是 `GO`，只不过某些情况下 `VO（G）`中的东西会和 `GO` 中的东西有所关联而已“映射机制”

**堆栈内存释放**
JS 中的内存分为堆栈内存和栈内存

堆内存：存储引用数据类型值（对象：键值对， 函数：代码字符串）
栈内存： 提供 JS 代码执行的环境和存储基本类型值
堆内存释放：
让所有引用堆内存空间地址的变量赋值为 null 即可，没有变量占用这个堆内存了浏览器会在空闲的时候把他释放掉

栈内存释放：
一般情况下，当函数执行完成，所形成的私有作用域（栈内存）都会自动释放掉，在栈内存中存储的基本值也都会释放掉，但也有特殊不销毁的情况：

函数执行完成，当前形成的栈内存中，某些内容被栈内存以外的变量占用了，此时栈内存不能释放，一旦释放外面找不到原有的内容了
全局栈内存只有在页面关闭的时候才会被释放掉

如果当前栈内存没有被释放，那么之前在栈内存中存储的基本值也不会被释放。能够一直保存下来
数据类型创建步骤
基本数据类型

`var a = 12;`
创建一个值
创建一个变量
让变量和值关联在一起
基本数据类型值都是直接存储到栈内存中的

引用数据类型

`var a = {n:12};`
创建一个堆内存
把键值对存储到内存中
堆内存地址放到栈中，共变量调用
引用数据类型值都是先开辟一个堆内存，把东西存储进去，最后把地址放到栈中供变量关联使用所有的指针赋值哦都是指针的关联指向
